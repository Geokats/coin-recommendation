\documentclass[12pt]{article}

%%%%% Greek language and fonts %%%%%%
\usepackage[cm-default]{fontspec}
\setromanfont{FreeSerif}
\setsansfont{FreeSans}
\setmonofont{FreeMono}

\usepackage[a4paper, margin=0.75in]{geometry}
\usepackage{multicol}

%%%%%%%%%%%%%%%%%%%%%%%% Headers and Footers %%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyheadoffset{10pt}

\lhead{Approximate Nearest Neighboor \& Clustering}
\chead{}
\rhead{Γιώργος Κατσογιάννης}

\lfoot{}
\cfoot{\thepage}
\rfoot{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Math packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath, amsfonts, amsthm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Graphs and Diagrams %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{float}
\usepackage{csvsimple}

% \usepackage{subfig}
\usepackage{graphicx}
\usepackage{subcaption}

\usepackage{forest}
\usepackage{wrapfig}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Links %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Source code package %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{cmd}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	% numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstdefinestyle{data}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\small\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	% numbers=left,
	numbersep=5pt,
	% showspaces=false,
	% showstringspaces=true,
	% showtabs=true,
	tabsize=4
}


\usepgfplotslibrary{fillbetween}
\usetikzlibrary{patterns}
\begin{document}

\pagenumbering{arabic}
\thispagestyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Title %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{multicols}{2}
	\begin{flushleft}
		\small{
		Εθνικό και Καποδιστριακό Πανεπιστήμιο Αθηνών\\
		Τμήμα Πληροφορικής \& Τηλεπικοινωνιών\\
		Ανάπτυξη Λογισμικού για Αλγ. Προβλήματα\\
		}
	\end{flushleft}

	\columnbreak

	\begin{flushright}
		\small{
		Γιώργος Κατσογιάννης-Μεϊμαράκης\\
		sdi1400065@di.uoa.gr\\
		Χειμερινό Εξάμηνο 2018-19
		}
	\end{flushright}
\end{multicols}

\begin{center}
	\LARGE{\bfseries{Approximate Nearest Neighboor \& Clustering}}
\end{center}

\noindent\makebox[\linewidth]{\rule{\paperwidth}{1pt}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Table of Contents %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand*\contentsname{Περιεχόμενα}
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%% Main Document %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Μεταγλώττιση \& Εκτέλεση}
\subsection{Μεταγλώττιση}
Τα προγράμματα μεταγλωττίζονται με τη χρήση του αρχείου Makefile και συγκεκριμένα
τις εντολές:

\begin{itemize}
	\item \verb|make|
	\begin{itemize}
		\item Για τη δημιουργία και όλων των εκτελέσιμων
	\end{itemize}
	\item \verb|make lsh|
	\begin{itemize}
		\item Για τη δημιουργία μόνο του εκτελέσιμου lsh
	\end{itemize}
	\item \verb|make cube|
	\begin{itemize}
		\item Για τη δημιουργία μόνο του εκτελέσιμου cube
	\end{itemize}
	\item \verb|make cluster|
	\begin{itemize}
		\item Για τη δημιουργία μόνο του εκτελέσιμου cluster
	\end{itemize}
\end{itemize}

\subsection{Εκτέλεση}
\subsubsection{LSH}
\begin{lstlisting}[style=cmd]
	./lsh -d <input file> -q <query file> -k <int> -L <int> -o <output file>
\end{lstlisting}

\subsubsection{Παράμετροι LSH}
\begin{itemize}
	\item $L$ είναι το πλήθος των hash tables που θα δημιουργηθούν
	\item $k$ είναι το 	πλήθος των συναρτήσεων κατακερματισμού $h_i$ ανά hash table
\end{itemize}

\subsubsection{Hypercube}
\begin{lstlisting}[style=cmd]
	./cube -d <input file> -q <query file> -k <int> -M <int> -p <int> -o <output file>
\end{lstlisting}

\subsubsection{Παράμετροι Hypercube}
\begin{itemize}
	\item $k$ είναι η διάσταση του υπερκύβου
	\item $M$ είναι το μέγιστο πλήθος σημείων που θα ελέγχονται σε κάθε αναζήτηση
	\item $p$ είναι το μέγιστο πλήθος κορυφών που θα ελέγχονται ανά αναζήτηση
\end{itemize}

\subsubsection{Cluster}
\begin{lstlisting}[style=cmd]
	./cluster -i <input file> -c <configuration file> -o <output file> -d <metric>
\end{lstlisting}

\subsection{Input File}
Τα αρχεία εισόδου όλων των προγραμμάτων του project πρέπει να έχουν την ακόλουθη
μορφή:

\begin{lstlisting}[style=data]
@metric cosine
x0	0	16	35	5	32	31	14	10	11	78	55	10	45	83	11	6	14	57	...
x1	14	35	19	20	3	1	13	11	16	119	85	5	0	5	24	26	0	27	...
x2	0	1	5	3	44	40	20	14	10	100	63	7	44	47	9	6	7	70	...
x3	12	47	14	25	2	3	4	7	14	122	90	7	0	0	6	14	0	24	...
...
\end{lstlisting}


Η πρώτη γραμμή δίνει τη μετρική που θα χρησιμοποιήσει το πρόγραμμα. Κάθε επόμενη
γραμμή δίνει και ένα σημείο του συνόλου δεδομένων. Για κάθε σημείο πρώτα δίνεται
το όνομά του και μετά τα στοιχεία του, τα οποία διαχωρίζονται μεταξύ τους με
tabs.

\subsection{Configuration File}

\section{Εργαλεία Ανάπτυξης Project}
\subsection{Version Control (Git/Github)}

\subsection{Unit Testing (CppUnit)}

\section{Οργάνωση Αρχείων \& Φακέλων}
\begin{wrapfigure}[17]{l}{0.3\textwidth}
	\begin{forest}
		for tree={
		font=\ttfamily,
		grow'=0,
		child anchor=west,
		parent anchor=south,
		anchor=west,
		calign=first,
		edge path={
		\noexpand\path [draw, \forestoption{edge}]
		(!u.south west) +(7.5pt,0) |- node[fill,inner sep=1.25pt] {} (.child anchor)\forestoption{edge label};
		},
		before typesetting nodes={
		if n=1
		{insert before={[,phantom]}}
		{}
		},
		fit=band,
		before computing xy={l=15pt},
		}
		[project
			[bin
				[...]
			]
			[data
				% [input\_small.txt]
				% [query\_small.txt]
				[...]
			]
			[doc
				[readme
					% [Makefile]
					% [readme.pdf]
					% [readme.xtx]
					[...]
				]
				[...]
			]
			[include
				% [hash\_table.hpp]
				% [hasher.hpp]
				% [point.hpp]
				% [searcher.hpp]
				% [util.hpp]
				[...]
			]
			[obj
				[...]
			]
			[src
				% [cluster.cpp]
				% [cube.cpp]
				% [hash\_table.cpp]
				% [hasher.cpp]
				% [lsh.cpp]
				% [point.cpp]
				% [searcher.cpp]
				% [util.cpp]
				[...]
			]
			[test
				[...]
			]
			[Makefile]
		]
	\end{forest}

	% \caption{Κατάλογος Αρχείων}
\end{wrapfigure}

Ο κώδικας οργανώνεται σε διαφορετικά αρχεία ανάλογα με το σκοπό και τη
λειτουργικότητά του. Συγκεκριμένα στα εξής αρχεία:

\subsection{Οργάνωση Φακέλων}
\subsubsection{Φάκελος bin}
Περιέχει τα τελικά εκτελέσιμα αρχεία που παράγονται με τη μεταγλώττιση του
κώδικα.

\subsubsection{Φάκελος data}
Περιέχει όλα τα σύνολα δεδομένων που χρησιμοποιούνται.

\subsubsection{Φάκελος doc}
Περιέχει τα αρχεία που περιγράφουν το project (readme, configuration files).

\subsubsection{Φάκελος include}
Περιέχει όλα τα αρχεία κεφαλίδας (.hpp) των αρχείων κώδικα που αναπτύχθηκαν για
το project.

\subsubsection{Φάκελος obj}
Περιέχει τα object files που παράγονται κατά τη μεταγλώττιση του κώδικα.

\subsubsection{Φάκελος src}
Περιέχει όλα τα αρχεία πηγαίου κώδικα (.cpp) που αναπτύχθηκαν για το project.

\subsubsection{Φάκελος test}

\subsection{Οργάνωση Αρχείων Κώδικα}
\subsubsection{Αρχείο lsh.cpp}
Περιέχει την συνάρτηση main που εκτελεί το LSH πάνω σε δοσμένο dataset και
εκτυπώνει αποτελέσματα και στατιστικά.

\subsubsection{Αρχείο cube.cpp}
Περιέχει την συνάρτηση main που εκτελεί τον υπερκύβο πάνω σε δοσμένο dataset και
εκτυπώνει αποτελέσματα και στατιστικά.

\subsubsection{Αρχείο cluster.cpp}

\subsubsection{Αρχείο searcher.cpp/.hpp}
Περιέχουν τη virtual κλάση searcher και την υλοποίηση των υποκλάσεών της, lsh
και hypercube.

\subsubsection{Αρχείο clusterCreator.cpp/.hpp}

\subsubsection{Αρχείο hash\_table.cpp/.hpp}
Περιέχει την υλοποίηση των πινάκων κατακερματισμού που χρησιμοποιεί
ο αλγόριθμος LSH

\subsubsection{Αρχείο hasher.cpp/.hpp}
Περιέχει την υλοποίηση των μετρικών που χρησιμοποιούνται και από τις
δύο μεθόδους (ευκλείδιας απόστασης και συνημιτόνου)

\subsubsection{Αρχείο point.cpp/.hpp}
Περιέχει την υλοποίηση του ΑΤΔ point το οποίο αναπαριστά τα σημεία
των datasets και τα διανύσματα των αλγορίθμων

\subsubsection{Αρχείο util.cpp/.hpp}
Περιέχει γενικές συναρτήσεις που χρησιμοποιούνται και από τις δύο
μεθόδους

\section{Approximate Nearest Neighboor}
\subsection{Latent Semantic Hashing (LSH)}

\subsection{Υπερκύβος}


\section{Σύγκριση Μεθόδων LSH \& Hypercube}
Για την σύγκριση των δύο μεθόδων θα χρησιμοποιήσουμε την \textbf{μετρική συνημιτόνου}.

\subsection{Ενδεικτικές Εκτελέσεις}
Στη συνέχεια βλέπουμε τις επιδόσεις των μεθόδων για διαφορετικές παραμέτρους.
Είναι πολύ σημαντικό να σημειώθει ως σημείο αναφοράς ότι ο ντετερμινιστικός
αλγόριθμος πλησιέστερου γείτονα τρέχει κατά μέσο όρο σε χρόνο $0.05$s.
Χρησιμοποιούμε ένα dataset 10000 σημείων ως είσοδο και ένα dataset 100 σημείων
για queries.

\subsubsection{LSH}
\begin{table}[H]
	\centering
	\begin{tabular}{c | c || c | c | c}
		$k$ & $L$ & Max Approx. & Avg. Approx & Avg. Time \\
		\hline \hline
		3   & 5   & 1           & 1            & 0.2292   \\
		\hline
		4   & 5   & 1.0559      & 1.0011       & 0.2089   \\
		\hline
		6   & 5   & 1.1177      & 1.0050       & 0.1469   \\
		\hline
		8   & 5   & 1.1070     & 1.0058       & 0.0900   \\
		\hline
		10  & 5   & 1.5502     & 1.0367       & 0.0456   \\
		\hline
		12  & 5   & 1.8626     & 1.0400       & 0.0416   \\
		\hline
		14  & 5   & 2.1293     & 1.0489       & 0.0298   \\
		\hline
		15  & 5   & 2.1771     & 1.0786       & 0.0202   \\
		\hline
		16  & 5   & 2.3813     & 1.0956       & 0.0274   \\
		\hline
		16  & 6   & 2.1134     & 1.0783       & 0.0421   \\
		\hline
		16  & 7   & 2.0756     & 1.0808       & 0.0357   \\
		\hline
		16  & 8   & 1.8307     & 1.0690       & 0.0235   \\
		\hline
		\textbf{16}  & \textbf{9}   & \textbf{1.7638}     & \textbf{1.0438}       & \textbf{0.0341}   \\
		\hline
		16  & 10   & 1.6221     & 1.0505       & 0.0464   \\
	\end{tabular}
\end{table}

\subsubsection{Hypercube}
\begin{table}[H]
	\centering
	\begin{tabular}{c | c | c || c | c | c}
		$k$ & $M$ & $p$ & Max Approx. & Avg. Approx & Avg. Time \\
		\hline \hline
		4   & 500 & 4   & 5.0334      & 1.3621      & 0.0027    \\
		\hline
		5   & 500 & 4   & 4.9590      & 1.4644      & 0.0025    \\
		\hline
		6   & 500 & 4   & 3.3547      & 1.2262      & 0.0024    \\
		\hline
		6   & 1000 & 4   & 3.1239      & 1.1584      & 0.0050    \\
		\hline
		6   & 1000 & 6   & 1.7797      & 1.0844      & 0.0054    \\
		\hline
		6   & 1000 & 10   & 2.4349      & 1.0989      & 0.0052    \\
		\hline
		6   & 2000 & 10   & 2.6356      & 1.0793      & 0.0069    \\
		\hline
		7   & 3000 & 15   & 2.2929      & 1.0542      & 0.0119    \\
		\hline
		7   & 3000 & 32   & 1.7262      & 1.0447      & 0.0131    \\
		\hline
		\textbf{7}   & \textbf{3000} & \textbf{64}   & \textbf{1.6721}      & \textbf{1.0509}      & \textbf{0.0138}    \\
		\hline
		5   & 3000 & 15   & 2.2484      & 1.0857      & 0.0149    \\
		\hline
		5   & 3000 & 32   & 1.8530      & 1.0498      & 0.0150    \\
	\end{tabular}
\end{table}

\subsubsection{Παρατηρήσεις \& Σχόλια}
Από τις παραπάνω εκτελέσεις παρατηρούμε ότι και οι δύο μέθοδοι καταφέρνουν
αρκετά καλά αποτελέσματα με σχετικά παρόμοια ακρίβεια (συγκεκριμένα για $k=16,
L=9$ στο LSH και $k=7,M=3000,p=64$ στον υπερκύβο). Παρατηρούμε όμως ότι η
μέθοδος του υπερκύβου είναι περίπου 2 φορές πιο γρήγορη από το LSH και περίπου
3 φορές πιο γρήγορη από τον ντετερμινιστικό αλγόριθμο.

Επίσης, για το LSH παρατηρούμε ότι δεν έχει νόημα η παράμετρος $k$ να παίρνει
τιμές κάτω από 14 για τη συγκεκριμένη μετρική, διότι ο χρόνος που πετυχαίνει
είναι χειρότερος από τον ντετερμινιστικό αλγόριθμο. Αυτό συμβαίνει διότι η
συνάρτηση κατακερματισμού έχει πολλές συγκρούσεις για μικρά $k$.

Ακόμη, στον υπερκύβο παρατηρούμε ότι είναι σημαντικό όταν αυξάνεται το $k$ να
αυξάνεται και το $p$, το οποίο είναι λογικό αφού όταν έχουμε πολλές κορυφές θα
πρέπει να επιτρέπουμε στον αλγόριθμο να επισκέπτεται περισσότερες.

\subsection{Κατανάλωση Χώρου}
\subsubsection{LSH}
Για την υλοποίηση του LSH χρησιμοποιούνται $L$ hash tables, καθένα απο τα οποία
χρησιμοποιεί τη δική του συνάρτηση κατακερματισμού και κάθε μια απ' αυτές έχει
$k$ "υπο-συναρτήσεις" με ξεχωριστά διανύσματα ανάλογα τη μετρική.

Για κάθε hash table δημιουργούνται $k$ buckets, τα οποία αναπαρίστανται με C++
vectors και σε αυτά αποθηκεύονται οι δείκτες των σημείων που είναι αποθηκευμένα
σε μια εξωτερική δομή για την αποφυγή της πολλαπλής (για την ακρίβεια $k$-πλής)
αποθήκευσης των σημείων.

\subsubsection{Υπερκύβος}
Στην περίπτωση του υπερκύβου, έχουμε $2^k$ κορυφές οι οποίες έχουν ίδια μορφή με
τα buckets των hash tables (C++ vectors με pointers σε σημεία), μόνο μια
συνάρτηση κατακερματισμού με $2^k$ υποσυναρτήσεις και $k$ συναρτήσεις
$f: x \rightarrow [f_1(h_1(x),\dots,f_{2^k}(h_{2^k}(x))) \in {\{0,1\}}^{2^k}]$.
Για την υλοποίηση των συναρτήσεων $f$ χρησιμοποιείται η δομή unordered\_map της
C++ όπου κάθε τιμή που δεν περιέχεται ήδη στο map προβάλεται τυχαία στο ${\{0,1\}}$.

\section{Clustering}
\subsection{Initialisation}
\subsubsection{Random Selection}

\subsubsection{K-means++}

\subsection{Assignments}
\subsubsection{Lloyd's Assignment}

\subsubsection{Assignment by Range Search with LSH}

\subsubsection{Assignment by Range Search with Hypercube}

\subsection{Update}
\subsubsection{K-means}

\subsubsection{Partitioning Around Medoids (PAM)}

\end{document}
